// NthRoot(2.0, 25.0)
double midPowerOfN(double mid, int n, double m)
{
    double ans = 1.0;
    for (int i = 1; i <= n; ++i)
    {
        ans *= mid;
        if (ans > m)
            return 2.0;
    }
    if (fabs(ans - m) < 1e-9)
        return 1.0;
    return 0.0;
}
double NthRoot(int n, double m)
{
    double l = 0.0, h = m, mid;
    double tolerance = 1e-9;
    double closest = -1.0;
    // while (h - l > tolerance)
    // for safety 100 is good
    for (int i = 0; i <= 100; ++i)
    {
        mid = (l + h) / 2.0;
        double ans = midPowerOfN(mid, n, m);
        if (ans == 1.0)
        {
            return mid;
        }
        else if (ans == 0.0)
        {
            l = mid;
        }
        else
        {
            h = mid;
            closest = mid;
        }
    }
    return closest;
}
